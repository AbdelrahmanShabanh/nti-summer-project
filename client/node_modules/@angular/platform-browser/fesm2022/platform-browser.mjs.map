{"version":3,"file":"platform-browser.mjs","sources":["../../../../../../packages/platform-browser/src/browser/generic_browser_adapter.ts","../../../../../../packages/platform-browser/src/browser/browser_adapter.ts","../../../../../../packages/platform-browser/src/browser/testability.ts","../../../../../../packages/platform-browser/src/browser/xhr.ts","../../../../../../packages/platform-browser/src/dom/events/event_manager.ts","../../../../../../packages/platform-browser/src/dom/shared_styles_host.ts","../../../../../../packages/platform-browser/src/dom/dom_renderer.ts","../../../../../../packages/platform-browser/src/dom/events/dom_events.ts","../../../../../../packages/platform-browser/src/dom/events/key_events.ts","../../../../../../packages/platform-browser/src/browser.ts","../../../../../../packages/platform-browser/src/browser/meta.ts","../../../../../../packages/platform-browser/src/browser/title.ts","../../../../../../packages/platform-browser/src/dom/util.ts","../../../../../../packages/platform-browser/src/browser/tools/browser.ts","../../../../../../packages/platform-browser/src/browser/tools/common_tools.ts","../../../../../../packages/platform-browser/src/browser/tools/tools.ts","../../../../../../packages/platform-browser/src/dom/debug/by.ts","../../../../../../packages/platform-browser/src/dom/events/hammer_gestures.ts","../../../../../../packages/platform-browser/src/security/dom_sanitization_service.ts","../../../../../../packages/platform-browser/src/hydration.ts","../../../../../../packages/platform-browser/src/version.ts","../../../../../../packages/platform-browser/src/platform-browser.ts","../../../../../../packages/platform-browser/public_api.ts","../../../../../../packages/platform-browser/index.ts","../../../../../../packages/platform-browser/platform-browser.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵDomAdapter as DomAdapter} from '@angular/common';\n\n\n\n/**\n * Provides DOM operations in any browser environment.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\nexport abstract class GenericBrowserDomAdapter extends DomAdapter {\n  override readonly supportsDOMEvents: boolean = true;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵparseCookieValue as parseCookieValue, ɵsetRootDomAdapter as setRootDomAdapter} from '@angular/common';\n\nimport {GenericBrowserDomAdapter} from './generic_browser_adapter';\n\n/**\n * A `DomAdapter` powered by full browser DOM APIs.\n *\n * @security Tread carefully! Interacting with the DOM directly is dangerous and\n * can introduce XSS risks.\n */\n/* tslint:disable:requireParameterType no-console */\nexport class BrowserDomAdapter extends GenericBrowserDomAdapter {\n  static makeCurrent() {\n    setRootDomAdapter(new BrowserDomAdapter());\n  }\n\n  override onAndCancel(el: Node, evt: any, listener: any): Function {\n    el.addEventListener(evt, listener);\n    return () => {\n      el.removeEventListener(evt, listener);\n    };\n  }\n  override dispatchEvent(el: Node, evt: any) {\n    el.dispatchEvent(evt);\n  }\n  override remove(node: Node): void {\n    if (node.parentNode) {\n      node.parentNode.removeChild(node);\n    }\n  }\n  override createElement(tagName: string, doc?: Document): HTMLElement {\n    doc = doc || this.getDefaultDocument();\n    return doc.createElement(tagName);\n  }\n  override createHtmlDocument(): Document {\n    return document.implementation.createHTMLDocument('fakeTitle');\n  }\n  override getDefaultDocument(): Document {\n    return document;\n  }\n\n  override isElementNode(node: Node): boolean {\n    return node.nodeType === Node.ELEMENT_NODE;\n  }\n\n  override isShadowRoot(node: any): boolean {\n    return node instanceof DocumentFragment;\n  }\n\n  /** @deprecated No longer being used in Ivy code. To be removed in version 14. */\n  override getGlobalEventTarget(doc: Document, target: string): EventTarget|null {\n    if (target === 'window') {\n      return window;\n    }\n    if (target === 'document') {\n      return doc;\n    }\n    if (target === 'body') {\n      return doc.body;\n    }\n    return null;\n  }\n  override getBaseHref(doc: Document): string|null {\n    const href = getBaseElementHref();\n    return href == null ? null : relativePath(href);\n  }\n  override resetBaseElement(): void {\n    baseElement = null;\n  }\n  override getUserAgent(): string {\n    return window.navigator.userAgent;\n  }\n  override getCookie(name: string): string|null {\n    return parseCookieValue(document.cookie, name);\n  }\n}\n\nlet baseElement: HTMLElement|null = null;\nfunction getBaseElementHref(): string|null {\n  baseElement = baseElement || document.querySelector('base');\n  return baseElement ? baseElement.getAttribute('href') : null;\n}\n\n// based on urlUtils.js in AngularJS 1\nlet urlParsingNode: HTMLAnchorElement|undefined;\nfunction relativePath(url: any): string {\n  urlParsingNode = urlParsingNode || document.createElement('a');\n  urlParsingNode.setAttribute('href', url);\n  const pathName = urlParsingNode.pathname;\n  return pathName.charAt(0) === '/' ? pathName : `/${pathName}`;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ɵgetDOM as getDOM} from '@angular/common';\nimport {GetTestability, Testability, TestabilityRegistry, ɵglobal as global, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nexport class BrowserGetTestability implements GetTestability {\n  addToWindow(registry: TestabilityRegistry): void {\n    global['getAngularTestability'] = (elem: any, findInAncestors: boolean = true) => {\n      const testability = registry.findTestabilityInTree(elem, findInAncestors);\n      if (testability == null) {\n        throw new RuntimeError(\n            RuntimeErrorCode.TESTABILITY_NOT_FOUND,\n            (typeof ngDevMode === 'undefined' || ngDevMode) &&\n                'Could not find testability for element.');\n      }\n      return testability;\n    };\n\n    global['getAllAngularTestabilities'] = () => registry.getAllTestabilities();\n\n    global['getAllAngularRootElements'] = () => registry.getAllRootElements();\n\n    const whenAllStable = (callback: (didWork: boolean) => void) => {\n      const testabilities = global['getAllAngularTestabilities']() as Testability[];\n      let count = testabilities.length;\n      let didWork = false;\n      const decrement = function(didWork_: boolean) {\n        didWork = didWork || didWork_;\n        count--;\n        if (count == 0) {\n          callback(didWork);\n        }\n      };\n      testabilities.forEach((testability) => {\n        testability.whenStable(decrement);\n      });\n    };\n\n    if (!global['frameworkStabilizers']) {\n      global['frameworkStabilizers'] = [];\n    }\n    global['frameworkStabilizers'].push(whenAllStable);\n  }\n\n  findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean):\n      Testability|null {\n    if (elem == null) {\n      return null;\n    }\n    const t = registry.getTestability(elem);\n    if (t != null) {\n      return t;\n    } else if (!findInAncestors) {\n      return null;\n    }\n    if (getDOM().isShadowRoot(elem)) {\n      return this.findTestabilityInTree(registry, (<any>elem).host, true);\n    }\n    return this.findTestabilityInTree(registry, elem.parentElement, true);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {XhrFactory} from '@angular/common';\nimport {Injectable} from '@angular/core';\n\n/**\n * A factory for `HttpXhrBackend` that uses the `XMLHttpRequest` browser API.\n */\n@Injectable()\nexport class BrowserXhr implements XhrFactory {\n  build(): XMLHttpRequest {\n    return new XMLHttpRequest();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Inject, Injectable, InjectionToken, NgZone, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../../errors';\n\n/**\n * The injection token for the event-manager plug-in service.\n *\n * @publicApi\n */\nexport const EVENT_MANAGER_PLUGINS =\n    new InjectionToken<EventManagerPlugin[]>('EventManagerPlugins');\n\n/**\n * An injectable service that provides event management for Angular\n * through a browser plug-in.\n *\n * @publicApi\n */\n@Injectable()\nexport class EventManager {\n  private _plugins: EventManagerPlugin[];\n  private _eventNameToPlugin = new Map<string, EventManagerPlugin>();\n\n  /**\n   * Initializes an instance of the event-manager service.\n   */\n  constructor(@Inject(EVENT_MANAGER_PLUGINS) plugins: EventManagerPlugin[], private _zone: NgZone) {\n    plugins.forEach((plugin) => {\n      plugin.manager = this;\n    });\n    this._plugins = plugins.slice().reverse();\n  }\n\n  /**\n   * Registers a handler for a specific element and event.\n   *\n   * @param element The HTML element to receive event notifications.\n   * @param eventName The name of the event to listen for.\n   * @param handler A function to call when the notification occurs. Receives the\n   * event object as an argument.\n   * @returns  A callback function that can be used to remove the handler.\n   */\n  addEventListener(element: HTMLElement, eventName: string, handler: Function): Function {\n    const plugin = this._findPluginFor(eventName);\n    return plugin.addEventListener(element, eventName, handler);\n  }\n\n  /**\n   * Retrieves the compilation zone in which event listeners are registered.\n   */\n  getZone(): NgZone {\n    return this._zone;\n  }\n\n  /** @internal */\n  _findPluginFor(eventName: string): EventManagerPlugin {\n    let plugin = this._eventNameToPlugin.get(eventName);\n    if (plugin) {\n      return plugin;\n    }\n\n    const plugins = this._plugins;\n    plugin = plugins.find((plugin) => plugin.supports(eventName));\n    if (!plugin) {\n      throw new RuntimeError(\n          RuntimeErrorCode.NO_PLUGIN_FOR_EVENT,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              `No event manager plugin found for event ${eventName}`);\n    }\n\n    this._eventNameToPlugin.set(eventName, plugin);\n    return plugin;\n  }\n}\n\nexport abstract class EventManagerPlugin {\n  constructor(private _doc: any) {}\n\n  // Using non-null assertion because it's set by EventManager's constructor\n  manager!: EventManager;\n\n  abstract supports(eventName: string): boolean;\n\n  abstract addEventListener(element: HTMLElement, eventName: string, handler: Function): Function;\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, isPlatformServer} from '@angular/common';\nimport {APP_ID, CSP_NONCE, Inject, Injectable, OnDestroy, Optional, PLATFORM_ID} from '@angular/core';\n\n/** The style elements attribute name used to set value of `APP_ID` token. */\nconst APP_ID_ATTRIBUTE_NAME = 'ng-app-id';\n\n@Injectable()\nexport class SharedStylesHost implements OnDestroy {\n  // Maps all registered host nodes to a list of style nodes that have been added to the host node.\n  private readonly styleRef = new Map < string /** Style string */, {\n    elements: HTMLStyleElement[];\n    usage: number\n  }\n  > ();\n  private readonly hostNodes = new Set<Node>();\n  private readonly styleNodesInDOM: Map<string, HTMLStyleElement>|null;\n  private readonly platformIsServer: boolean;\n\n  constructor(\n      @Inject(DOCUMENT) private readonly doc: Document,\n      @Inject(APP_ID) private readonly appId: string,\n      @Inject(CSP_NONCE) @Optional() private nonce?: string|null,\n      @Inject(PLATFORM_ID) readonly platformId: object = {}) {\n    this.styleNodesInDOM = this.collectServerRenderedStyles();\n    this.platformIsServer = isPlatformServer(platformId);\n    this.resetHostNodes();\n  }\n\n  addStyles(styles: string[]): void {\n    for (const style of styles) {\n      const usageCount = this.changeUsageCount(style, 1);\n\n      if (usageCount === 1) {\n        this.onStyleAdded(style);\n      }\n    }\n  }\n\n  removeStyles(styles: string[]): void {\n    for (const style of styles) {\n      const usageCount = this.changeUsageCount(style, -1);\n\n      if (usageCount <= 0) {\n        this.onStyleRemoved(style);\n      }\n    }\n  }\n\n  ngOnDestroy(): void {\n    const styleNodesInDOM = this.styleNodesInDOM;\n    if (styleNodesInDOM) {\n      styleNodesInDOM.forEach((node) => node.remove());\n      styleNodesInDOM.clear();\n    }\n\n    for (const style of this.getAllStyles()) {\n      this.onStyleRemoved(style);\n    }\n\n    this.resetHostNodes();\n  }\n\n  addHost(hostNode: Node): void {\n    this.hostNodes.add(hostNode);\n\n    for (const style of this.getAllStyles()) {\n      this.addStyleToHost(hostNode, style);\n    }\n  }\n\n  removeHost(hostNode: Node): void {\n    this.hostNodes.delete(hostNode);\n  }\n\n  private getAllStyles(): IterableIterator<string> {\n    return this.styleRef.keys();\n  }\n\n  private onStyleAdded(style: string): void {\n    for (const host of this.hostNodes) {\n      this.addStyleToHost(host, style);\n    }\n  }\n\n  private onStyleRemoved(style: string): void {\n    const styleRef = this.styleRef;\n    styleRef.get(style)?.elements?.forEach((node) => node.remove());\n    styleRef.delete(style);\n  }\n\n  private collectServerRenderedStyles(): Map<string, HTMLStyleElement>|null {\n    const styles = this.doc.head?.querySelectorAll<HTMLStyleElement>(\n        `style[${APP_ID_ATTRIBUTE_NAME}=\"${this.appId}\"]`);\n\n    if (styles?.length) {\n      const styleMap = new Map<string, HTMLStyleElement>();\n\n      styles.forEach((style) => {\n        if (style.textContent != null) {\n          styleMap.set(style.textContent, style);\n        }\n      });\n\n      return styleMap;\n    }\n\n    return null;\n  }\n\n  private changeUsageCount(style: string, delta: number): number {\n    const map = this.styleRef;\n    if (map.has(style)) {\n      const styleRefValue = map.get(style)!;\n      styleRefValue.usage += delta;\n\n      return styleRefValue.usage;\n    }\n\n    map.set(style, {usage: delta, elements: []});\n    return delta;\n  }\n\n  private getStyleElement(host: Node, style: string): HTMLStyleElement {\n    const styleNodesInDOM = this.styleNodesInDOM;\n    const styleEl = styleNodesInDOM?.get(style);\n    if (styleEl?.parentNode === host) {\n      // `styleNodesInDOM` cannot be undefined due to the above `styleNodesInDOM?.get`.\n      styleNodesInDOM!.delete(style);\n\n      styleEl.removeAttribute(APP_ID_ATTRIBUTE_NAME);\n\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        // This attribute is solely used for debugging purposes.\n        styleEl.setAttribute('ng-style-reused', '');\n      }\n\n      return styleEl;\n    } else {\n      const styleEl = this.doc.createElement('style');\n\n      if (this.nonce) {\n        styleEl.setAttribute('nonce', this.nonce);\n      }\n\n      styleEl.textContent = style;\n\n      if (this.platformIsServer) {\n        styleEl.setAttribute(APP_ID_ATTRIBUTE_NAME, this.appId);\n      }\n\n      return styleEl;\n    }\n  }\n\n  private addStyleToHost(host: Node, style: string): void {\n    const styleEl = this.getStyleElement(host, style);\n\n    host.appendChild(styleEl);\n\n    const styleRef = this.styleRef;\n    const styleElRef = styleRef.get(style)?.elements;\n    if (styleElRef) {\n      styleElRef.push(styleEl);\n    } else {\n      styleRef.set(style, {elements: [styleEl], usage: 1});\n    }\n  }\n\n  private resetHostNodes(): void {\n    const hostNodes = this.hostNodes;\n    hostNodes.clear();\n    // Re-add the head element back since this is the default host.\n    hostNodes.add(this.doc.head);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, isPlatformServer, ɵgetDOM as getDOM} from '@angular/common';\nimport {APP_ID, CSP_NONCE, Inject, Injectable, InjectionToken, NgZone, OnDestroy, PLATFORM_ID, Renderer2, RendererFactory2, RendererStyleFlags2, RendererType2, ViewEncapsulation, ɵRuntimeError as RuntimeError} from '@angular/core';\n\nimport {RuntimeErrorCode} from '../errors';\n\nimport {EventManager} from './events/event_manager';\nimport {SharedStylesHost} from './shared_styles_host';\n\nexport const NAMESPACE_URIS: {[ns: string]: string} = {\n  'svg': 'http://www.w3.org/2000/svg',\n  'xhtml': 'http://www.w3.org/1999/xhtml',\n  'xlink': 'http://www.w3.org/1999/xlink',\n  'xml': 'http://www.w3.org/XML/1998/namespace',\n  'xmlns': 'http://www.w3.org/2000/xmlns/',\n  'math': 'http://www.w3.org/1998/MathML/',\n};\n\nconst COMPONENT_REGEX = /%COMP%/g;\n\nexport const COMPONENT_VARIABLE = '%COMP%';\nexport const HOST_ATTR = `_nghost-${COMPONENT_VARIABLE}`;\nexport const CONTENT_ATTR = `_ngcontent-${COMPONENT_VARIABLE}`;\n\n/**\n * The default value for the `REMOVE_STYLES_ON_COMPONENT_DESTROY` DI token.\n */\nconst REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT = false;\n\n/**\n * A [DI token](guide/glossary#di-token \"DI token definition\") that indicates whether styles\n * of destroyed components should be removed from DOM.\n *\n * By default, the value is set to `false`. This will be changed in the next major version.\n * @publicApi\n */\nexport const REMOVE_STYLES_ON_COMPONENT_DESTROY =\n    new InjectionToken<boolean>('RemoveStylesOnCompDestroy', {\n      providedIn: 'root',\n      factory: () => REMOVE_STYLES_ON_COMPONENT_DESTROY_DEFAULT,\n    });\n\nexport function shimContentAttribute(componentShortId: string): string {\n  return CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function shimHostAttribute(componentShortId: string): string {\n  return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId);\n}\n\nexport function shimStylesContent(compId: string, styles: string[]): string[] {\n  return styles.map(s => s.replace(COMPONENT_REGEX, compId));\n}\n\n@Injectable()\nexport class DomRendererFactory2 implements RendererFactory2, OnDestroy {\n  private readonly rendererByCompId =\n      new Map<string, EmulatedEncapsulationDomRenderer2|NoneEncapsulationDomRenderer>();\n  private readonly defaultRenderer: Renderer2;\n  private readonly platformIsServer: boolean;\n\n  constructor(\n      private readonly eventManager: EventManager,\n      private readonly sharedStylesHost: SharedStylesHost,\n      @Inject(APP_ID) private readonly appId: string,\n      @Inject(REMOVE_STYLES_ON_COMPONENT_DESTROY) private removeStylesOnCompDestroy: boolean,\n      @Inject(DOCUMENT) private readonly doc: Document,\n      @Inject(PLATFORM_ID) readonly platformId: Object,\n      readonly ngZone: NgZone,\n      @Inject(CSP_NONCE) private readonly nonce: string|null = null,\n  ) {\n    this.platformIsServer = isPlatformServer(platformId);\n    this.defaultRenderer =\n        new DefaultDomRenderer2(eventManager, doc, ngZone, this.platformIsServer);\n  }\n\n  createRenderer(element: any, type: RendererType2|null): Renderer2 {\n    if (!element || !type) {\n      return this.defaultRenderer;\n    }\n\n    if (this.platformIsServer && type.encapsulation === ViewEncapsulation.ShadowDom) {\n      // Domino does not support shadow DOM.\n      type = {...type, encapsulation: ViewEncapsulation.Emulated};\n    }\n\n    const renderer = this.getOrCreateRenderer(element, type);\n    // Renderers have different logic due to different encapsulation behaviours.\n    // Ex: for emulated, an attribute is added to the element.\n    if (renderer instanceof EmulatedEncapsulationDomRenderer2) {\n      renderer.applyToHost(element);\n    } else if (renderer instanceof NoneEncapsulationDomRenderer) {\n      renderer.applyStyles();\n    }\n\n    return renderer;\n  }\n\n  private getOrCreateRenderer(element: any, type: RendererType2): Renderer2 {\n    const rendererByCompId = this.rendererByCompId;\n    let renderer = rendererByCompId.get(type.id);\n\n    if (!renderer) {\n      const doc = this.doc;\n      const ngZone = this.ngZone;\n      const eventManager = this.eventManager;\n      const sharedStylesHost = this.sharedStylesHost;\n      const removeStylesOnCompDestroy = this.removeStylesOnCompDestroy;\n      const platformIsServer = this.platformIsServer;\n\n      switch (type.encapsulation) {\n        case ViewEncapsulation.Emulated:\n          renderer = new EmulatedEncapsulationDomRenderer2(\n              eventManager, sharedStylesHost, type, this.appId, removeStylesOnCompDestroy, doc,\n              ngZone, platformIsServer);\n          break;\n        case ViewEncapsulation.ShadowDom:\n          return new ShadowDomRenderer(\n              eventManager, sharedStylesHost, element, type, doc, ngZone, this.nonce,\n              platformIsServer);\n        default:\n          renderer = new NoneEncapsulationDomRenderer(\n              eventManager, sharedStylesHost, type, removeStylesOnCompDestroy, doc, ngZone,\n              platformIsServer);\n          break;\n      }\n\n      rendererByCompId.set(type.id, renderer);\n    }\n\n    return renderer;\n  }\n\n  ngOnDestroy() {\n    this.rendererByCompId.clear();\n  }\n}\n\nclass DefaultDomRenderer2 implements Renderer2 {\n  data: {[key: string]: any} = Object.create(null);\n\n  constructor(\n      private readonly eventManager: EventManager, private readonly doc: Document,\n      private readonly ngZone: NgZone, private readonly platformIsServer: boolean) {}\n\n  destroy(): void {}\n\n  destroyNode = null;\n\n  createElement(name: string, namespace?: string): any {\n    if (namespace) {\n      // TODO: `|| namespace` was added in\n      // https://github.com/angular/angular/commit/2b9cc8503d48173492c29f5a271b61126104fbdb to\n      // support how Ivy passed around the namespace URI rather than short name at the time. It did\n      // not, however extend the support to other parts of the system (setAttribute, setAttribute,\n      // and the ServerRenderer). We should decide what exactly the semantics for dealing with\n      // namespaces should be and make it consistent.\n      // Related issues:\n      // https://github.com/angular/angular/issues/44028\n      // https://github.com/angular/angular/issues/44883\n      return this.doc.createElementNS(NAMESPACE_URIS[namespace] || namespace, name);\n    }\n\n    return this.doc.createElement(name);\n  }\n\n  createComment(value: string): any {\n    return this.doc.createComment(value);\n  }\n\n  createText(value: string): any {\n    return this.doc.createTextNode(value);\n  }\n\n  appendChild(parent: any, newChild: any): void {\n    const targetParent = isTemplateNode(parent) ? parent.content : parent;\n    targetParent.appendChild(newChild);\n  }\n\n  insertBefore(parent: any, newChild: any, refChild: any): void {\n    if (parent) {\n      const targetParent = isTemplateNode(parent) ? parent.content : parent;\n      targetParent.insertBefore(newChild, refChild);\n    }\n  }\n\n  removeChild(parent: any, oldChild: any): void {\n    if (parent) {\n      parent.removeChild(oldChild);\n    }\n  }\n\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): any {\n    let el: any = typeof selectorOrNode === 'string' ? this.doc.querySelector(selectorOrNode) :\n                                                       selectorOrNode;\n    if (!el) {\n      throw new RuntimeError(\n          RuntimeErrorCode.ROOT_NODE_NOT_FOUND,\n          (typeof ngDevMode === 'undefined' || ngDevMode) &&\n              `The selector \"${selectorOrNode}\" did not match any elements`);\n    }\n    if (!preserveContent) {\n      el.textContent = '';\n    }\n    return el;\n  }\n\n  parentNode(node: any): any {\n    return node.parentNode;\n  }\n\n  nextSibling(node: any): any {\n    return node.nextSibling;\n  }\n\n  setAttribute(el: any, name: string, value: string, namespace?: string): void {\n    if (namespace) {\n      name = namespace + ':' + name;\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.setAttributeNS(namespaceUri, name, value);\n      } else {\n        el.setAttribute(name, value);\n      }\n    } else {\n      el.setAttribute(name, value);\n    }\n  }\n\n  removeAttribute(el: any, name: string, namespace?: string): void {\n    if (namespace) {\n      const namespaceUri = NAMESPACE_URIS[namespace];\n      if (namespaceUri) {\n        el.removeAttributeNS(namespaceUri, name);\n      } else {\n        el.removeAttribute(`${namespace}:${name}`);\n      }\n    } else {\n      el.removeAttribute(name);\n    }\n  }\n\n  addClass(el: any, name: string): void {\n    el.classList.add(name);\n  }\n\n  removeClass(el: any, name: string): void {\n    el.classList.remove(name);\n  }\n\n  setStyle(el: any, style: string, value: any, flags: RendererStyleFlags2): void {\n    if (flags & (RendererStyleFlags2.DashCase | RendererStyleFlags2.Important)) {\n      el.style.setProperty(style, value, flags & RendererStyleFlags2.Important ? 'important' : '');\n    } else {\n      el.style[style] = value;\n    }\n  }\n\n  removeStyle(el: any, style: string, flags: RendererStyleFlags2): void {\n    if (flags & RendererStyleFlags2.DashCase) {\n      // removeProperty has no effect when used on camelCased properties.\n      el.style.removeProperty(style);\n    } else {\n      el.style[style] = '';\n    }\n  }\n\n  setProperty(el: any, name: string, value: any): void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && checkNoSyntheticProp(name, 'property');\n    el[name] = value;\n  }\n\n  setValue(node: any, value: string): void {\n    node.nodeValue = value;\n  }\n\n  listen(target: 'window'|'document'|'body'|any, event: string, callback: (event: any) => boolean):\n      () => void {\n    (typeof ngDevMode === 'undefined' || ngDevMode) && checkNoSyntheticProp(event, 'listener');\n    if (typeof target === 'string') {\n      target = getDOM().getGlobalEventTarget(this.doc, target);\n      if (!target) {\n        throw new Error(`Unsupported event target ${target} for event ${event}`);\n      }\n    }\n\n    return this.eventManager.addEventListener(\n               target, event, this.decoratePreventDefault(callback)) as VoidFunction;\n